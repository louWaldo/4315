Our approach to this problem is to create a series of lists, solving sub problem after subproblem.
Upon reading the input file, we extract every integer and real number with the use of a regular expression. This results in a multidimensional list of strings, with one list dedicated per line of the input file.
We then "flatten" these lists, resulting in a single 1-D list of strings. To avoid the issue of having elements sorted in lexicographical order, we convert this list of strings to a list of integers/floating pint numbers so that they may be sorted numerically into another list. From here, we use the sorted list of numbers for two things, first is to create a list of unique numbers, without any duplicates. The other is to recurssively count the frequency of every number in the list. These two lists must be of the same size since any unique number can only have one unique frequency. Leveraging this one-to-one mapping, we zip these two together into a list of tuples. 
As of now, this list of tuples is sorted according to the first element of the tuple, that being the unique number. To simplify the process of printing the highest frequency elements, we create a new list of tuples identical to the first one that is sorted according to the second element of the tuple, that being the frequency..
From here we recurssively print the results to the output file using rtraverse(). To deal with rank ties, as soon as we have printed the first k frequent elements, we take note of what the frequency was for the very last number printed, and save that frequency into a variable 't'. We also copy the rest of the list that has not yet been traversed into a new list. This new list as well as 't' are both passed to rtraverse2(). From this function, we only need to check whether the frequency of every subsequent element is equal to 't'. If it is, then we also print this to the output file. 

python3 topK.py "k=3;input=input.txt;output=freq.txt"
